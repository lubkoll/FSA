<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Spacy: Spacy Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Spacy
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Spacy Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace of the Spacy library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1CG.html">CG</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Conjugate gradient methods for convex and nonconvex problems (CG, Truncated CG, Regularized CG and Truncated Regularized CG). </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1Newton.html">Newton</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Newton methods, largely following </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1CompositeStep.html">CompositeStep</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains the affine covariant composite step method of. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1ProductSpace.html">ProductSpace</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>A product space that supports distinction between primal and dual variables. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1FEniCS.html">FEniCS</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains vector spaces, functionals and operators for <a href="www.fenicsproject.org">FEniCS</a>. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1Kaskade.html">Kaskade</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains vector spaces, functionals and operators for <a href="http://www.zib.de/projects/kaskade7-finite-element-toolbox">Kaskade7</a>. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1Scalar.html">Scalar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains functionals and operators for scalar problems. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1Rn.html">Rn</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains functionals and operators for finite dimensional vector space problems, based on <a href="http://eigen.tuxfamily.org">Eigen</a>. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1Generic.html">Generic</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains generic implementations for easier definitions of vectors and a generic scalar product implementation. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1Mixin.html">Mixin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Contains small independent components that are frequently used and can be added to classes via (multiple) inheritance. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1Optional.html">Optional</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy_1_1Detail.html">Detail</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1C1Functional.html">C1Functional</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased differentiable functional \(f:\ X \to \mathbb{R} \).  <a href="classSpacy_1_1C1Functional.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1C1Operator.html">C1Operator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased differentiable operator \(A:\ X \to Y \).  <a href="classSpacy_1_1C1Operator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1C2Functional.html">C2Functional</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased twice differentiable functional \(f:\ X \to \mathbb{R} \).  <a href="classSpacy_1_1C2Functional.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1DynamicOperator.html">DynamicOperator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased time-dependent operator \(A:\ [0,T] \times X \to Y \).  <a href="classSpacy_1_1DynamicOperator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1DynamicLinearOperator.html">DynamicLinearOperator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased time-dependent linear operator \(A:\ [0,T] \times X \to Y \).  <a href="classSpacy_1_1DynamicLinearOperator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1DynamicC1Operator.html">DynamicC1Operator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased time-dependent differentiable operator \(A:\ [0,T] \times X \to Y \).  <a href="classSpacy_1_1DynamicC1Operator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1Functional.html">Functional</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased functional \(f:\ X \to \mathbb{R} \).  <a href="classSpacy_1_1Functional.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1LinearOperator.html">LinearOperator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased linear operator \(A:\ X \to Y \).  <a href="classSpacy_1_1LinearOperator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1IndefiniteLinearSolver.html">IndefiniteLinearSolver</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased indefinite linear solver. Additionally monitors if the underlying operator is positive definite.  <a href="classSpacy_1_1IndefiniteLinearSolver.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1Operator.html">Operator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased operator \(A:\ X \to Y \).  <a href="classSpacy_1_1Operator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1Vector.html">Vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased vector.  <a href="classSpacy_1_1Vector.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1ZeroVectorCreator.html">ZeroVectorCreator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Each <a class="el" href="classSpacy_1_1VectorSpace.html" title="Function space .">VectorSpace</a> needs a zero-vector creator to support generation of vector space elements.  <a href="classSpacy_1_1ZeroVectorCreator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1DampingFactor.html">DampingFactor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple model of a damping factor \(\nu\) that is computed up to a prescribed accuracy \(\varepsilon\).  <a href="classSpacy_1_1DampingFactor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1LipschitzConstant.html">LipschitzConstant</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple model for a Lipschitz constant \(\omega\).  <a href="classSpacy_1_1LipschitzConstant.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1Parameter.html">Parameter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic parameters for simple algorithms.  <a href="classSpacy_1_1Parameter.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1HilbertSpaceNorm.html">HilbertSpaceNorm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">\( \|\cdot\|=\sqrt{(\cdot,\cdot)} \)  <a href="classSpacy_1_1HilbertSpaceNorm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1AdaptiveInducedScalarProduct.html">AdaptiveInducedScalarProduct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Induced scalar product \((x,y)_M = (Mx)y\), where \(M:X\rightarrow X^*\).  <a href="classSpacy_1_1AdaptiveInducedScalarProduct.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1InducedScalarProduct.html">InducedScalarProduct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Induced scalar product \((x,y)_M = (Mx)y\), where \(M:X\rightarrow X^*\).  <a href="classSpacy_1_1InducedScalarProduct.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1PrimalInducedScalarProduct.html">PrimalInducedScalarProduct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Induced scalar product for the primal variables (i.e. for constrained optimization problems).  <a href="classSpacy_1_1PrimalInducedScalarProduct.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1Real.html">Real</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Real number.  <a href="classSpacy_1_1Real.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1AddArithmeticOperators.html">AddArithmeticOperators</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing some operations for vectors via CRTP.  <a href="classSpacy_1_1AddArithmeticOperators.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1FunctionalBase.html">FunctionalBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1OperatorBase.html">OperatorBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1VectorBase.html">VectorBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for vector implementations.  <a href="classSpacy_1_1VectorBase.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1CallOfUndefinedFunctionException.html">CallOfUndefinedFunctionException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception to be thrown if a virtual function is not implemented.  <a href="classSpacy_1_1CallOfUndefinedFunctionException.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1GenericException.html">GenericException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic exception class that serves as base for all exceptions in this library.  <a href="classSpacy_1_1GenericException.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1IncompatibleSpaceException.html">IncompatibleSpaceException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception to be thrown when encountering incompatible spaces.  <a href="classSpacy_1_1IncompatibleSpaceException.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1RegularityTestFailedException.html">RegularityTestFailedException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception to be thrown if regularity test fails.  <a href="classSpacy_1_1RegularityTestFailedException.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1SingularOperatorException.html">SingularOperatorException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception to be thrown if singular operators are inverted.  <a href="classSpacy_1_1SingularOperatorException.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSpacy_1_1Logger.html">Logger</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSpacy_1_1IsVoid.html">IsVoid</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSpacy_1_1Require.html">Require</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if Concept is satisfied.  <a href="structSpacy_1_1Require.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function space \((X,\|\cdot\|)\).  <a href="classSpacy_1_1VectorSpace.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>PRIMAL</b> = 0, 
<b>DUAL</b> = 1
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1LinearOperator.html">LinearOperator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a2205e2a2c4bb5242665bbc09929d35d2">d1</a> (const <a class="el" href="classSpacy_1_1C1Operator.html">C1Operator</a> &amp;A, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For an operator \( A: X\to Y \), compute \(A&#39;\) at \(x\in X\) as linear operator \( A&#39;(x): X \to Y \).  <a href="#a2205e2a2c4bb5242665bbc09929d35d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#ab6646eb7068eb9f1369e639cf0b620a2">d1</a> (const <a class="el" href="classSpacy_1_1C2Functional.html">C2Functional</a> &amp;f, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For a functional \( f: X\to \mathbb{R} \), compute \(f&#39;\) at \(x\in X\) as dual element \( f&#39;(x) \in X^* \).  <a href="#ab6646eb7068eb9f1369e639cf0b620a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1LinearOperator.html">LinearOperator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a569d8fc0b4a0e292f257dd6307a25c8f">d2</a> (const <a class="el" href="classSpacy_1_1C2Functional.html">C2Functional</a> &amp;f, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For a functional \( f: X\to \mathbb{R} \), compute \(f&#39;&#39;\) at \(x\in X\) as linear operator \( f&#39;&#39;(x): X \to X^* \).  <a href="#a569d8fc0b4a0e292f257dd6307a25c8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1be097dacbf27785979de79ed5b3178"></a><!-- doxytag: member="Spacy::operator^" ref="ab1be097dacbf27785979de79ed5b3178" args="(const LinearOperator &amp;A, int k)" -->
LinearSolver&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#ab1be097dacbf27785979de79ed5b3178">operator^</a> (const <a class="el" href="classSpacy_1_1LinearOperator.html">LinearOperator</a> &amp;A, int k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access solver via A^-1. Throws for k!=-1. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6defec6ee302bf4c1054afc65c9fcb95"></a><!-- doxytag: member="Spacy::operator^" ref="a6defec6ee302bf4c1054afc65c9fcb95" args="(LinearOperator &amp;&amp;A, int k)" -->
LinearSolver&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a6defec6ee302bf4c1054afc65c9fcb95">operator^</a> (<a class="el" href="classSpacy_1_1LinearOperator.html">LinearOperator</a> &amp;&amp;A, int k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access solver via A^-1. Throws for k!=-1. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad08055ec05275c6042d516d4726b5e8f"></a><!-- doxytag: member="Spacy::axpy" ref="ad08055ec05275c6042d516d4726b5e8f" args="(LinearOperator &amp;A, double a, LinearOperator B)" -->
<a class="el" href="classSpacy_1_1LinearOperator.html">LinearOperator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>axpy</b> (<a class="el" href="classSpacy_1_1LinearOperator.html">LinearOperator</a> &amp;A, double a, <a class="el" href="classSpacy_1_1LinearOperator.html">LinearOperator</a> B)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae0a1cbb3d98d6ac0a82727959038f4b4"></a><!-- doxytag: member="Spacy::operator*" ref="ae0a1cbb3d98d6ac0a82727959038f4b4" args="(Arithmetic a, Vector x)" -->
template&lt;class Arithmetic , class  = std::enable_if_t&lt; std::is_arithmetic&lt;Arithmetic&gt;::value &gt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#ae0a1cbb3d98d6ac0a82727959038f4b4">operator*</a> (Arithmetic a, <a class="el" href="classSpacy_1_1Vector.html">Vector</a> x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication with arithmetic types (double,float,int,...). <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0120fd6b1d7580a9f7b8f24e646cbc6c"></a><!-- doxytag: member="Spacy::operator*" ref="a0120fd6b1d7580a9f7b8f24e646cbc6c" args="(Vector x, Arithmetic a)" -->
template&lt;class Arithmetic , class  = std::enable_if_t&lt; std::is_arithmetic&lt;Arithmetic&gt;::value &gt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a0120fd6b1d7580a9f7b8f24e646cbc6c">operator*</a> (<a class="el" href="classSpacy_1_1Vector.html">Vector</a> x, Arithmetic a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication with arithmetic types (double,float,int,...). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19486acb05af1627ec49c376b204a61c"></a><!-- doxytag: member="Spacy::operator+" ref="a19486acb05af1627ec49c376b204a61c" args="(Vector x, const Vector &amp;y)" -->
<a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a19486acb05af1627ec49c376b204a61c">operator+</a> (<a class="el" href="classSpacy_1_1Vector.html">Vector</a> x, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of vectors \(z=x+y\). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9eaf4be1a4e8f3ee03e4c4fdafa5687d"></a><!-- doxytag: member="Spacy::operator&#45;" ref="a9eaf4be1a4e8f3ee03e4c4fdafa5687d" args="(Vector x, const Vector &amp;y)" -->
<a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a9eaf4be1a4e8f3ee03e4c4fdafa5687d">operator-</a> (<a class="el" href="classSpacy_1_1Vector.html">Vector</a> x, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract vectors \(z=x-y\). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d84603fc2bfbefca6a020b1217519ad"></a><!-- doxytag: member="Spacy::operator*" ref="a1d84603fc2bfbefca6a020b1217519ad" args="(const Vector &amp;x, const Vector &amp;y)" -->
<a class="el" href="classSpacy_1_1Real.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a1d84603fc2bfbefca6a020b1217519ad">operator*</a> (const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;x, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute scalar product \(z=x*y=(x,y)\). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86a4fc266aa19a07b0af16388907354b"></a><!-- doxytag: member="Spacy::norm" ref="a86a4fc266aa19a07b0af16388907354b" args="(const Vector &amp;x)" -->
<a class="el" href="classSpacy_1_1Real.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a86a4fc266aa19a07b0af16388907354b">norm</a> (const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute norm, where the norm associated with the underlying function space is used \( z = \|x\| \). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac354f06d21282619482e3ef4a841cd76"></a><!-- doxytag: member="Spacy::checkDualPairing" ref="ac354f06d21282619482e3ef4a841cd76" args="(const Vector &amp;x, const Vector &amp;y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkDualPairing</b> (const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;x, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0e5e7a61e6d2996df2b3e86371d38dfa"></a><!-- doxytag: member="Spacy::operator*" ref="a0e5e7a61e6d2996df2b3e86371d38dfa" args="(const Mixin::Get&lt; T &gt; &amp;x, Vector y)" -->
template&lt;class T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const Mixin::Get&lt; T &gt; &amp;x, <a class="el" href="classSpacy_1_1Vector.html">Vector</a> y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6656b636307ec4d5552477027b724f46"></a><!-- doxytag: member="Spacy::operator*" ref="a6656b636307ec4d5552477027b724f46" args="(const Vector &amp;x, const Mixin::Get&lt; T &gt; &amp;y)" -->
template&lt;class T , typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;x, const Mixin::Get&lt; T &gt; &amp;y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a011c3af8fa33fc2da22f9667edaeba29"></a><!-- doxytag: member="Spacy::operator*" ref="a011c3af8fa33fc2da22f9667edaeba29" args="(const Mixin::Get&lt; Real &gt; &amp;x, Vector y)" -->
<a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const Mixin::Get&lt; <a class="el" href="classSpacy_1_1Real.html">Real</a> &gt; &amp;x, <a class="el" href="classSpacy_1_1Vector.html">Vector</a> y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ad73bdbb0377bd088f1007894a4a824"></a><!-- doxytag: member="Spacy::operator*" ref="a7ad73bdbb0377bd088f1007894a4a824" args="(const Vector &amp;x, const Mixin::Get&lt; Real &gt; &amp;y)" -->
<a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;x, const Mixin::Get&lt; <a class="el" href="classSpacy_1_1Real.html">Real</a> &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="affaca762d59da675eef594854762cdcd"></a><!-- doxytag: member="Spacy::creator" ref="affaca762d59da675eef594854762cdcd" args="(VectorSpace &amp;space)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>creator</b> (<a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a> &amp;space)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aed55e3a3401be0e74e174a12858baffa"></a><!-- doxytag: member="Spacy::creator" ref="aed55e3a3401be0e74e174a12858baffa" args="(const VectorSpace &amp;space)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>creator</b> (const <a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a> &amp;space)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7f0661bfdb52144b9ff0b9bbdd81f69"></a><!-- doxytag: member="Spacy::zero" ref="ac7f0661bfdb52144b9ff0b9bbdd81f69" args="(const VectorSpace &amp;space)" -->
<a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#ac7f0661bfdb52144b9ff0b9bbdd81f69">zero</a> (const <a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a> &amp;space)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new vector \(v=0\). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1CG_1_1LinearSolver.html">CG::LinearSolver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a158f06b6790d44613c6533fbd3822e6a">makeCGSolver</a> (<a class="el" href="classSpacy_1_1Operator.html">Operator</a> A, CallableOperator P, <a class="el" href="classSpacy_1_1Real.html">Real</a> relativeAccuracy=1e-15, Real eps=1e-15, bool verbose=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct conjugate gradient method.  <a href="#a158f06b6790d44613c6533fbd3822e6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1CG_1_1LinearSolver.html">CG::LinearSolver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#af70adbdd6fafbe87bd7c79be078851d6">makeRCGSolver</a> (<a class="el" href="classSpacy_1_1Operator.html">Operator</a> A, CallableOperator P, <a class="el" href="classSpacy_1_1Real.html">Real</a> relativeAccuracy=1e-15, Real eps=1e-15, bool verbose=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct regularized conjugate gradient method.  <a href="#af70adbdd6fafbe87bd7c79be078851d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1CG_1_1LinearSolver.html">CG::LinearSolver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a8c2664d93c0a0049cd3849a3a0c973a8">makeTCGSolver</a> (<a class="el" href="classSpacy_1_1Operator.html">Operator</a> A, CallableOperator P, <a class="el" href="classSpacy_1_1Real.html">Real</a> relativeAccuracy=1e-15, Real eps=1e-15, bool verbose=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct truncated conjugate gradient method.  <a href="#a8c2664d93c0a0049cd3849a3a0c973a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1CG_1_1LinearSolver.html">CG::LinearSolver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#af214c1f5a7c2e48d16370a7a386ca8df">makeTRCGSolver</a> (<a class="el" href="classSpacy_1_1Operator.html">Operator</a> A, CallableOperator P, <a class="el" href="classSpacy_1_1Real.html">Real</a> relativeAccuracy=1e-15, Real eps=1e-15, bool verbose=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct truncated regularized conjugate gradient method.  <a href="#af214c1f5a7c2e48d16370a7a386ca8df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81f372bdfa76c83a44edab9f33c2e8c8"></a><!-- doxytag: member="Spacy::operator*" ref="a81f372bdfa76c83a44edab9f33c2e8c8" args="(const LipschitzConstant &amp;x, Real y)" -->
<a class="el" href="classSpacy_1_1Real.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classSpacy_1_1LipschitzConstant.html">LipschitzConstant</a> &amp;x, <a class="el" href="classSpacy_1_1Real.html">Real</a> y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2f966e1b7480cdbd9ac1d9efc5b32f3"></a><!-- doxytag: member="Spacy::operator*" ref="af2f966e1b7480cdbd9ac1d9efc5b32f3" args="(Real x, const LipschitzConstant &amp;y)" -->
<a class="el" href="classSpacy_1_1Real.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classSpacy_1_1Real.html">Real</a> x, const <a class="el" href="classSpacy_1_1LipschitzConstant.html">LipschitzConstant</a> &amp;y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NewtonGroup.html#ga448b8e78b2e84ed78e70c42114ea7599">localNewton</a> (const <a class="el" href="classSpacy_1_1C1Operator.html">C1Operator</a> &amp;F, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;x0, const <a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a> &amp;p=<a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Local Newton method.  <a href="group__NewtonGroup.html#ga448b8e78b2e84ed78e70c42114ea7599"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NewtonGroup.html#gafbe5e25f46f7b0d237f5e9971cef998a">localNewton</a> (const <a class="el" href="classSpacy_1_1C1Operator.html">C1Operator</a> &amp;F, const <a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a> &amp;p=<a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Local Newton method with default initial iterate (x0=0).  <a href="group__NewtonGroup.html#gafbe5e25f46f7b0d237f5e9971cef998a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NewtonGroup.html#ga6c18ad252cb530e4f6734eb4e4fda481">covariantNewton</a> (const <a class="el" href="classSpacy_1_1C1Operator.html">C1Operator</a> &amp;F, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;x0, const <a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a> &amp;p=<a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a>(), const std::function&lt; bool(const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;)&gt; &amp;errorEstimator={})</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine covariant Newton method.  <a href="group__NewtonGroup.html#ga6c18ad252cb530e4f6734eb4e4fda481"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NewtonGroup.html#ga2d469322482680319bf81d865ed57068">covariantNewton</a> (const <a class="el" href="classSpacy_1_1C1Operator.html">C1Operator</a> &amp;F, const <a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a> &amp;p=<a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a>(), const std::function&lt; bool(const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;)&gt; &amp;errorEstimator={})</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine covariant Newton method.  <a href="group__NewtonGroup.html#ga2d469322482680319bf81d865ed57068"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NewtonGroup.html#gaa32f667c573986b2b2721ec6532fc832">contravariantNewton</a> (const <a class="el" href="classSpacy_1_1C1Operator.html">C1Operator</a> &amp;F, const <a class="el" href="classSpacy_1_1Vector.html">Vector</a> &amp;x0, const <a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a> &amp;p=<a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine contravariant Newton method.  <a href="group__NewtonGroup.html#gaa32f667c573986b2b2721ec6532fc832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NewtonGroup.html#gace045630c7f0c7a1a5a48d2d0807f608">contravariantNewton</a> (const <a class="el" href="classSpacy_1_1C1Operator.html">C1Operator</a> &amp;F, const <a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a> &amp;p=<a class="el" href="structSpacy_1_1Newton_1_1Parameter.html">Newton::Parameter</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine contravariant Newton method.  <a href="group__NewtonGroup.html#gace045630c7f0c7a1a5a48d2d0807f608"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1C1Operator.html">C1Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a002fe344fa6d04a6ac59a74ea25fddb6">derivative</a> (<a class="el" href="classSpacy_1_1C2Functional.html">C2Functional</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative of a functional \( f: X\to \mathbb{R} \) as (nonlinear) operator \( f&#39;:X\to X^* \).  <a href="#a002fe344fa6d04a6ac59a74ea25fddb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classSpacy_1_1Vector.html">Spacy::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ProductSpaceGroup.html#gaa040ba5c24284687e0df19c99dd688a6">primalComponent</a> (::<a class="el" href="classSpacy_1_1Vector.html">Spacy::Vector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const ::<a class="el" href="classSpacy_1_1Vector.html">Spacy::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ProductSpaceGroup.html#ga88c5bcc74072f75c63ab7d9448f80a7e">primalComponent</a> (const ::<a class="el" href="classSpacy_1_1Vector.html">Spacy::Vector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classSpacy_1_1Vector.html">Spacy::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ProductSpaceGroup.html#gafe51c084e3b03205db94e91309e834f7">dualComponent</a> (::<a class="el" href="classSpacy_1_1Vector.html">Spacy::Vector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const ::<a class="el" href="classSpacy_1_1Vector.html">Spacy::Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ProductSpaceGroup.html#gabe5978657aab46b1575e2521b336407d">dualComponent</a> (const ::<a class="el" href="classSpacy_1_1Vector.html">Spacy::Vector</a> &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89ed08f6f5a05e3f35afa37fcebf4b06"></a><!-- doxytag: member="Spacy::abs" ref="a89ed08f6f5a05e3f35afa37fcebf4b06" args="(Real x)" -->
<a class="el" href="classSpacy_1_1Real.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a89ed08f6f5a05e3f35afa37fcebf4b06">abs</a> (<a class="el" href="classSpacy_1_1Real.html">Real</a> x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute absolute value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acffef7eb409609abe7ad87aaad28503f"></a><!-- doxytag: member="Spacy::pow" ref="acffef7eb409609abe7ad87aaad28503f" args="(Real x, double y)" -->
<a class="el" href="classSpacy_1_1Real.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#acffef7eb409609abe7ad87aaad28503f">pow</a> (<a class="el" href="classSpacy_1_1Real.html">Real</a> x, double y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(x^y\). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa779bb3e2bf547cd0ed9ef47b3d711a3"></a><!-- doxytag: member="Spacy::sqrt" ref="aa779bb3e2bf547cd0ed9ef47b3d711a3" args="(Real x)" -->
<a class="el" href="classSpacy_1_1Real.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#aa779bb3e2bf547cd0ed9ef47b3d711a3">sqrt</a> (<a class="el" href="classSpacy_1_1Real.html">Real</a> x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\sqrt{x}\). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64093cc47f73b71ba92bc0dd37e9572b"></a><!-- doxytag: member="Spacy::cbrt" ref="a64093cc47f73b71ba92bc0dd37e9572b" args="(Real x)" -->
<a class="el" href="classSpacy_1_1Real.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a64093cc47f73b71ba92bc0dd37e9572b">cbrt</a> (<a class="el" href="classSpacy_1_1Real.html">Real</a> x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \( x^{1/3} \). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2408a53b27498ddeb762c52b51b71905"></a><!-- doxytag: member="Spacy::operator*" ref="a2408a53b27498ddeb762c52b51b71905" args="(const Mixin::Get&lt; Real &gt; &amp;x, Real y)" -->
<a class="el" href="classSpacy_1_1Real.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const Mixin::Get&lt; <a class="el" href="classSpacy_1_1Real.html">Real</a> &gt; &amp;x, <a class="el" href="classSpacy_1_1Real.html">Real</a> y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0d849d3130fd1252cf3a58b4f194e6b"></a><!-- doxytag: member="Spacy::operator*" ref="af0d849d3130fd1252cf3a58b4f194e6b" args="(Real x, const Mixin::Get&lt; Real &gt; &amp;y)" -->
<a class="el" href="classSpacy_1_1Real.html">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classSpacy_1_1Real.html">Real</a> x, const Mixin::Get&lt; <a class="el" href="classSpacy_1_1Real.html">Real</a> &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a00adbd58a88f8474c28da323effbcc26"></a><!-- doxytag: member="Spacy::operator+" ref="a00adbd58a88f8474c28da323effbcc26" args="(T &amp;&amp;x, const Real &amp;y)" -->
template&lt;class T , std::enable_if_t&lt; std::is_base_of&lt; Mixin::Get&lt; Real &gt;, std::decay_t&lt; T &gt; &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (T &amp;&amp;x, const <a class="el" href="classSpacy_1_1Real.html">Real</a> &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af24641d6a51293d3601c760ec310a1b1"></a><!-- doxytag: member="Spacy::operator+" ref="af24641d6a51293d3601c760ec310a1b1" args="(Real x, T &amp;&amp;y)" -->
template&lt;class T , std::enable_if_t&lt; std::is_base_of&lt; Mixin::Get&lt; Real &gt;, std::decay_t&lt; T &gt; &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="classSpacy_1_1Real.html">Real</a> x, T &amp;&amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ce5976cd9ab32a6eecaa92fc3ea803a"></a><!-- doxytag: member="Spacy::operator&#45;" ref="a0ce5976cd9ab32a6eecaa92fc3ea803a" args="(T &amp;&amp;x, const Real &amp;y)" -->
template&lt;class T , std::enable_if_t&lt; std::is_base_of&lt; Mixin::Get&lt; Real &gt;, std::decay_t&lt; T &gt; &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (T &amp;&amp;x, const <a class="el" href="classSpacy_1_1Real.html">Real</a> &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a92fe6ff3c620feb4c8299e6ac3959a42"></a><!-- doxytag: member="Spacy::operator&#45;" ref="a92fe6ff3c620feb4c8299e6ac3959a42" args="(Real x, T &amp;&amp;y)" -->
template&lt;class T , std::enable_if_t&lt; std::is_base_of&lt; Mixin::Get&lt; Real &gt;, std::decay_t&lt; T &gt; &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="classSpacy_1_1Real.html">Real</a> x, T &amp;&amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aeec0910b94a07ae8dfe79f971ea8425a"></a><!-- doxytag: member="Spacy::operator/" ref="aeec0910b94a07ae8dfe79f971ea8425a" args="(T &amp;&amp;x, const Real &amp;y)" -->
template&lt;class T , std::enable_if_t&lt; std::is_base_of&lt; Mixin::Get&lt; Real &gt;, std::decay_t&lt; T &gt; &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (T &amp;&amp;x, const <a class="el" href="classSpacy_1_1Real.html">Real</a> &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af180e266f73b104cb351ec67778b8cfd"></a><!-- doxytag: member="Spacy::operator/" ref="af180e266f73b104cb351ec67778b8cfd" args="(const Real &amp;x, T &amp;&amp;y)" -->
template&lt;class T , std::enable_if_t&lt; std::is_base_of&lt; Mixin::Get&lt; Real &gt;, std::decay_t&lt; T &gt; &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classSpacy_1_1Real.html">Real</a> &amp;x, T &amp;&amp;y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a3e51c65a8900b247c46021039c4c823a">makeScalarSpace</a> (bool defaultIndex=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct space of real numbers.  <a href="#a3e51c65a8900b247c46021039c4c823a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae44bfd08fa77272bab4149665b26233a"></a><!-- doxytag: member="Spacy::is" ref="ae44bfd08fa77272bab4149665b26233a" args="(const FromType &amp;x)" -->
template&lt;class ToType , class FromType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#ae44bfd08fa77272bab4149665b26233a">is</a> (const FromType &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if x can be cast to a reference of type ToType. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="abb0550fc1d402f00e42c165ae8eb3305"></a><!-- doxytag: member="Spacy::cast_ref" ref="abb0550fc1d402f00e42c165ae8eb3305" args="(FromType &amp;x)" -->
template&lt;class ToType , class FromType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ToType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#abb0550fc1d402f00e42c165ae8eb3305">cast_ref</a> (FromType &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cast x of type 'FromType&amp;' to 'ToType&amp;' <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a00fc9d674cd8813c4e20a05adf3aaaa4"></a><!-- doxytag: member="Spacy::cast_ref" ref="a00fc9d674cd8813c4e20a05adf3aaaa4" args="(const FromType &amp;x)" -->
template&lt;class ToType , class FromType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const ToType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a00fc9d674cd8813c4e20a05adf3aaaa4">cast_ref</a> (const FromType &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cast x of type 'const FromType&amp;' to 'const ToType&amp;' <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Origin , class Target &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a7dd8ce352c45e326cf8966befd5159ce">genericCopy</a> (const Origin &amp;x, Target &amp;y, std::function&lt; void(const Origin &amp;, Target &amp;)&gt; copyTargetIfConsistent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from x to y.  <a href="#a7dd8ce352c45e326cf8966befd5159ce"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Func , typename Tup &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#afbcee52cc294417930c5ccfc2fefb9f8">decltype</a> (auto) invoke(Func &amp;&amp;func</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke function with arguments contained in tup.  <a href="#afbcee52cc294417930c5ccfc2fefb9f8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="accc9a8a0cad11b10fb4453e6bea7a7e1"></a><!-- doxytag: member="Spacy::castAndAttach" ref="accc9a8a0cad11b10fb4453e6bea7a7e1" args="(Source &amp;source, ToAttach &amp;toAttach)" -->
template&lt;class Base , class Source , class ToAttach &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>castAndAttach</b> (Source &amp;source, ToAttach &amp;toAttach)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e6018674d6169a33a2fa75a35e2fef3"></a><!-- doxytag: member="Spacy::castAndDetach" ref="a9e6018674d6169a33a2fa75a35e2fef3" args="(Source &amp;source, ToAttach &amp;toAttach)" -->
template&lt;class Base , class Source , class ToAttach &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>castAndDetach</b> (Source &amp;source, ToAttach &amp;toAttach)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b66c8f2345b693504180dc7fb187958"></a><!-- doxytag: member="Spacy::makeBanachSpace" ref="a0b66c8f2345b693504180dc7fb187958" args="(ZeroVectorCreator &amp;&amp;creator, Norm norm)" -->
<a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a0b66c8f2345b693504180dc7fb187958">makeBanachSpace</a> (<a class="el" href="classSpacy_1_1ZeroVectorCreator.html">ZeroVectorCreator</a> &amp;&amp;creator, Norm <a class="el" href="namespaceSpacy.html#a86a4fc266aa19a07b0af16388907354b">norm</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct Banach space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a927756dd42df3e79c302df1f8f635b65"></a><!-- doxytag: member="Spacy::makeHilbertSpace" ref="a927756dd42df3e79c302df1f8f635b65" args="(ZeroVectorCreator &amp;&amp;creator, ScalarProduct scalarProduct, bool defaultIndex=false)" -->
<a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a927756dd42df3e79c302df1f8f635b65">makeHilbertSpace</a> (<a class="el" href="classSpacy_1_1ZeroVectorCreator.html">ZeroVectorCreator</a> &amp;&amp;creator, ScalarProduct scalarProduct, bool defaultIndex=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct Hilbert space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#a72844d3d381380c382cd9dce912e2664">connectAsPrimalDualPair</a> (<a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a> &amp;X, <a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a> &amp;Y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Relate function spaces.  <a href="#a72844d3d381380c382cd9dce912e2664"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpacy.html#aae18423491adef608743902f1c40844e">checkSpaceCompatibility</a> (const <a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a> &amp;V, const <a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a> &amp;W)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if V and W have the same index.  <a href="#aae18423491adef608743902f1c40844e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Main namespace of the Spacy library. </p>
<p>NAMESPACES </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2205e2a2c4bb5242665bbc09929d35d2"></a><!-- doxytag: member="Spacy::d1" ref="a2205e2a2c4bb5242665bbc09929d35d2" args="(const C1Operator &amp;A, const Vector &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSpacy_1_1LinearOperator.html">LinearOperator</a> <a class="el" href="namespaceSpacy.html#a2205e2a2c4bb5242665bbc09929d35d2">Spacy::d1</a> </td>
          <td>(</td>
          <td class="paramtype">const C1Operator &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For an operator \( A: X\to Y \), compute \(A&#39;\) at \(x\in X\) as linear operator \( A&#39;(x): X \to Y \). </p>
<p>For an operator \( A: X\to Y \), compute \(A&#39;\) at \(x\in X\) as linear operator \( A&#39;(x): X \to Y \).</p>
<p>Equivalent to calling A.linearization(x).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>differentiable operator </td></tr>
    <tr><td class="paramname">x</td><td>point of linearization </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>\(A&#39;(x)\), i.e. A.linearization(x). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>C1Operator, LinearOperator </dd></dl>

</div>
</div>
<a class="anchor" id="ab6646eb7068eb9f1369e639cf0b620a2"></a><!-- doxytag: member="Spacy::d1" ref="ab6646eb7068eb9f1369e639cf0b620a2" args="(const C2Functional &amp;f, const Vector &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSpacy_1_1Vector.html">Vector</a> <a class="el" href="namespaceSpacy.html#a2205e2a2c4bb5242665bbc09929d35d2">Spacy::d1</a> </td>
          <td>(</td>
          <td class="paramtype">const C2Functional &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For a functional \( f: X\to \mathbb{R} \), compute \(f&#39;\) at \(x\in X\) as dual element \( f&#39;(x) \in X^* \). </p>
<p>For a functional \( f: X\to \mathbb{R} \), compute \(f&#39;\) at \(x\in X\) as dual element \( f&#39;(x) \in X^* \).</p>
<p>Equivalent to calling f.d1(x).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>twice differentiable functional </td></tr>
    <tr><td class="paramname">x</td><td>point of linearization </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>\(f&#39;(x)\), i.e. f.d1(x). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSpacy_1_1C2Functional.html" title="Type-erased twice differentiable functional .">C2Functional</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a569d8fc0b4a0e292f257dd6307a25c8f"></a><!-- doxytag: member="Spacy::d2" ref="a569d8fc0b4a0e292f257dd6307a25c8f" args="(const C2Functional &amp;f, const Vector &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSpacy_1_1LinearOperator.html">LinearOperator</a> <a class="el" href="namespaceSpacy.html#a569d8fc0b4a0e292f257dd6307a25c8f">Spacy::d2</a> </td>
          <td>(</td>
          <td class="paramtype">const C2Functional &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For a functional \( f: X\to \mathbb{R} \), compute \(f&#39;&#39;\) at \(x\in X\) as linear operator \( f&#39;&#39;(x): X \to X^* \). </p>
<p>For a functional \( f: X\to \mathbb{R} \), compute \(f&#39;&#39;\) at \(x\in X\) as linear operator \( f&#39;&#39;(x): X \to X^* \).</p>
<p>Equivalent to calling f.hessian(x).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>twice differentiable functional </td></tr>
    <tr><td class="paramname">x</td><td>point of linearization </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>\(f&#39;&#39;(x)\), i.e. f.hessian(x). </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSpacy_1_1C2Functional.html" title="Type-erased twice differentiable functional .">C2Functional</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a158f06b6790d44613c6533fbd3822e6a"></a><!-- doxytag: member="Spacy::makeCGSolver" ref="a158f06b6790d44613c6533fbd3822e6a" args="(Operator A, CallableOperator P, Real relativeAccuracy=1e&#45;15, Real eps=1e&#45;15, bool verbose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSpacy_1_1CG_1_1LinearSolver.html">CG::LinearSolver</a> <a class="el" href="namespaceSpacy.html#a158f06b6790d44613c6533fbd3822e6a">Spacy::makeCGSolver</a> </td>
          <td>(</td>
          <td class="paramtype">Operator&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableOperator&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>relativeAccuracy</em> = <code>1e-15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct conjugate gradient method. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>operator </td></tr>
    <tr><td class="paramname">P</td><td>preconditioner </td></tr>
    <tr><td class="paramname">relativeAccuracy</td><td>relative accuracy </td></tr>
    <tr><td class="paramname">eps</td><td>maximal attainable accuracy </td></tr>
    <tr><td class="paramname">verbose</td><td>verbosity </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CGSolver(A,P,"CG") </dd></dl>

</div>
</div>
<a class="anchor" id="af70adbdd6fafbe87bd7c79be078851d6"></a><!-- doxytag: member="Spacy::makeRCGSolver" ref="af70adbdd6fafbe87bd7c79be078851d6" args="(Operator A, CallableOperator P, Real relativeAccuracy=1e&#45;15, Real eps=1e&#45;15, bool verbose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSpacy_1_1CG_1_1LinearSolver.html">CG::LinearSolver</a> <a class="el" href="namespaceSpacy.html#af70adbdd6fafbe87bd7c79be078851d6">Spacy::makeRCGSolver</a> </td>
          <td>(</td>
          <td class="paramtype">Operator&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableOperator&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>relativeAccuracy</em> = <code>1e-15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct regularized conjugate gradient method. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>operator </td></tr>
    <tr><td class="paramname">P</td><td>preconditioner </td></tr>
    <tr><td class="paramname">relativeAccuracy</td><td>relative accuracy </td></tr>
    <tr><td class="paramname">eps</td><td>maximal attainable accuracy </td></tr>
    <tr><td class="paramname">verbose</td><td>verbosity </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CGSolver(A,P,"RCG") </dd></dl>

</div>
</div>
<a class="anchor" id="a8c2664d93c0a0049cd3849a3a0c973a8"></a><!-- doxytag: member="Spacy::makeTCGSolver" ref="a8c2664d93c0a0049cd3849a3a0c973a8" args="(Operator A, CallableOperator P, Real relativeAccuracy=1e&#45;15, Real eps=1e&#45;15, bool verbose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSpacy_1_1CG_1_1LinearSolver.html">CG::LinearSolver</a> <a class="el" href="namespaceSpacy.html#a8c2664d93c0a0049cd3849a3a0c973a8">Spacy::makeTCGSolver</a> </td>
          <td>(</td>
          <td class="paramtype">Operator&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableOperator&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>relativeAccuracy</em> = <code>1e-15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct truncated conjugate gradient method. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>operator </td></tr>
    <tr><td class="paramname">P</td><td>preconditioner </td></tr>
    <tr><td class="paramname">relativeAccuracy</td><td>relative accuracy </td></tr>
    <tr><td class="paramname">eps</td><td>maximal attainable accuracy </td></tr>
    <tr><td class="paramname">verbose</td><td>verbosity </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CGSolver(A,P,"TCG") </dd></dl>

</div>
</div>
<a class="anchor" id="af214c1f5a7c2e48d16370a7a386ca8df"></a><!-- doxytag: member="Spacy::makeTRCGSolver" ref="af214c1f5a7c2e48d16370a7a386ca8df" args="(Operator A, CallableOperator P, Real relativeAccuracy=1e&#45;15, Real eps=1e&#45;15, bool verbose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSpacy_1_1CG_1_1LinearSolver.html">CG::LinearSolver</a> <a class="el" href="namespaceSpacy.html#af214c1f5a7c2e48d16370a7a386ca8df">Spacy::makeTRCGSolver</a> </td>
          <td>(</td>
          <td class="paramtype">Operator&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableOperator&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>relativeAccuracy</em> = <code>1e-15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct truncated regularized conjugate gradient method. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>operator </td></tr>
    <tr><td class="paramname">P</td><td>preconditioner </td></tr>
    <tr><td class="paramname">relativeAccuracy</td><td>relative accuracy </td></tr>
    <tr><td class="paramname">eps</td><td>maximal attainable accuracy </td></tr>
    <tr><td class="paramname">verbose</td><td>verbosity </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CGSolver(A,P,"TRCG") </dd></dl>

</div>
</div>
<a class="anchor" id="a002fe344fa6d04a6ac59a74ea25fddb6"></a><!-- doxytag: member="Spacy::derivative" ref="a002fe344fa6d04a6ac59a74ea25fddb6" args="(C2Functional f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSpacy_1_1C1Operator.html">C1Operator</a> <a class="el" href="namespaceSpacy.html#a002fe344fa6d04a6ac59a74ea25fddb6">Spacy::derivative</a> </td>
          <td>(</td>
          <td class="paramtype">C2Functional&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the derivative of a functional \( f: X\to \mathbb{R} \) as (nonlinear) operator \( f&#39;:X\to X^* \). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>twice differentiable functional </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>\(f&#39;\) </dd></dl>

</div>
</div>
<a class="anchor" id="a3e51c65a8900b247c46021039c4c823a"></a><!-- doxytag: member="Spacy::makeScalarSpace" ref="a3e51c65a8900b247c46021039c4c823a" args="(bool defaultIndex=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSpacy_1_1VectorSpace.html">VectorSpace</a> <a class="el" href="namespaceSpacy.html#a3e51c65a8900b247c46021039c4c823a">Spacy::makeScalarSpace</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultIndex</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct space of real numbers. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>::Spacy::Scalar::makeRealHilbertSpace() </dd></dl>

</div>
</div>
<a class="anchor" id="a7dd8ce352c45e326cf8966befd5159ce"></a><!-- doxytag: member="Spacy::genericCopy" ref="a7dd8ce352c45e326cf8966befd5159ce" args="(const Origin &amp;x, Target &amp;y, std::function&lt; void(const Origin &amp;, Target &amp;)&gt; copyTargetIfConsistent)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Origin , class Target &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceSpacy.html#a7dd8ce352c45e326cf8966befd5159ce">Spacy::genericCopy</a> </td>
          <td>(</td>
          <td class="paramtype">const Origin &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Target &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const Origin &amp;, Target &amp;)&gt;&#160;</td>
          <td class="paramname"><em>copyTargetIfConsistent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy from x to y. </p>
<p>One of Origin or Target is a <a class="el" href="classSpacy_1_1Vector.html" title="Type-erased vector.">Spacy::Vector</a>, the other is some other type. This function treats (nested) product space structures and uses copyTargetIfConsistent to copy single subspaces. </p>

</div>
</div>
<a class="anchor" id="afbcee52cc294417930c5ccfc2fefb9f8"></a><!-- doxytag: member="Spacy::decltype" ref="afbcee52cc294417930c5ccfc2fefb9f8" args="(auto) invoke(Func &amp;&amp;func" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename Tup &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tup <a class="el" href="namespaceSpacy.html#afbcee52cc294417930c5ccfc2fefb9f8">Spacy::decltype</a> </td>
          <td>(</td>
          <td class="paramtype">auto&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invoke function with arguments contained in tup. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>function to be invoked </td></tr>
    <tr><td class="paramname">tup</td><td>= (a0,a1,...) arguments, individual entries must be accessible with std::get.</td></tr>
  </table>
  </dd>
</dl>
<p>Candidates for Tup are std::tuple, std::array, std::pair.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>func(a0,a1,...) </dd></dl>

</div>
</div>
<a class="anchor" id="a72844d3d381380c382cd9dce912e2664"></a><!-- doxytag: member="Spacy::connectAsPrimalDualPair" ref="a72844d3d381380c382cd9dce912e2664" args="(VectorSpace &amp;X, VectorSpace &amp;Y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceSpacy.html#a72844d3d381380c382cd9dce912e2664">Spacy::connectAsPrimalDualPair</a> </td>
          <td>(</td>
          <td class="paramtype">VectorSpace &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorSpace &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Relate function spaces. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>primal space </td></tr>
    <tr><td class="paramname">Y</td><td>dual space</td></tr>
  </table>
  </dd>
</dl>
<p>Makes \(X\) the primal space of \(Y\) and makes \(Y\) the dual space of \(X\). This admits the evaluation of \(y(x)\) for \(x\in X\) and \(y\in Y\). </p>

</div>
</div>
<a class="anchor" id="aae18423491adef608743902f1c40844e"></a><!-- doxytag: member="Spacy::checkSpaceCompatibility" ref="aae18423491adef608743902f1c40844e" args="(const VectorSpace &amp;V, const VectorSpace &amp;W)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceSpacy.html#aae18423491adef608743902f1c40844e">Spacy::checkSpaceCompatibility</a> </td>
          <td>(</td>
          <td class="paramtype">const VectorSpace &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorSpace &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if V and W have the same index. </p>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>`V.index() != W.index()` throws <a class="el" href="classSpacy_1_1IncompatibleSpaceException.html" title="Exception to be thrown when encountering incompatible spaces.">IncompatibleSpaceException</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sat Nov 26 2016 18:04:01 for Spacy by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
