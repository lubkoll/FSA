// This file was automatically generated by friendly type erasure.
// Please do not modify.

// @cond#pragma once

#include <functional>
#include <ostream>
#include <Spacy/Util/table_util.hh>

namespace Spacy
{
    namespace Log
    {
        namespace PrinterDetail
        {
            template < class Interface >
            struct Functions
            {
                using delete_function = void ( * )( void* );
                using call_const_char_ptr_const_char_ptr_const_std_function_void_std_ostream_ref_ref_function =
                    void ( * )( Interface&, void*, const char* tag, const char* name,
                                const std::function< void( std::ostream& ) >& printable );

                delete_function del;
                call_const_char_ptr_const_char_ptr_const_std_function_void_std_ostream_ref_ref_function
                    call_const_char_ptr_const_char_ptr_const_std_function_void_std_ostream_ref_ref;
            };

            template < class Interface, class Impl >
            struct execution_wrapper
            {
                static void call_const_char_ptr_const_char_ptr_const_std_function_void_std_ostream_ref_ref(
                    Interface& interface, void* impl, const char* tag, const char* name,
                    const std::function< void( std::ostream& ) >& printable )
                {
                    static_cast< Impl* >( impl )->operator()( tag, name, printable );
                }
            };

            template < class Interface, class Impl >
            struct execution_wrapper< Interface, std::reference_wrapper< Impl > >
            {
                static void call_const_char_ptr_const_char_ptr_const_std_function_void_std_ostream_ref_ref(
                    Interface& interface, void* impl, const char* tag, const char* name,
                    const std::function< void( std::ostream& ) >& printable )
                {
                    static_cast< std::reference_wrapper< Impl >* >( impl )->get().operator()( tag, name, printable );
                }
            };

            template < class T >
            using TryMemFn_call_const_char_ptr_const_char_ptr_const_std_function_void_std_ostream_ref_ref =
                decltype( std::declval< T >().operator()( std::declval< const char* >(), std::declval< const char* >(),
                                                          std::declval< std::function< void( std::ostream& ) > >() ) );
            template < class T, class = void >
            struct HasMemFn_call_const_char_ptr_const_char_ptr_const_std_function_void_std_ostream_ref_ref
                : std::false_type
            {
            };
            template < class T >
            struct HasMemFn_call_const_char_ptr_const_char_ptr_const_std_function_void_std_ostream_ref_ref<
                T, type_erasure_table_detail::voider<
                       TryMemFn_call_const_char_ptr_const_char_ptr_const_std_function_void_std_ostream_ref_ref< T > > >
                : std::true_type
            {
            };

            template < class T >
            using PrinterConceptImpl = std::integral_constant<
                bool, HasMemFn_call_const_char_ptr_const_char_ptr_const_std_function_void_std_ostream_ref_ref<
                          type_erasure_table_detail::remove_reference_wrapper_t< T > >::value >;

            template < class Impl, class T, bool = std::is_same< Impl, T >::value >
            struct PrinterConcept : std::false_type
            {
            };
            template < class Impl, class T >
            struct PrinterConcept< Impl, T, false > : PrinterConceptImpl< T >
            {
            };
        }
    }
}

//@endcond
