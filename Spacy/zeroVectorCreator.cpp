// This file was automatically generated by friendly type erasure.
// Please do not modify.

#include "zeroVectorCreator.hh"

namespace Spacy
{
    ZeroVectorCreator::ZeroVectorCreator() noexcept : impl_( nullptr )
    {
    }

    ZeroVectorCreator::ZeroVectorCreator( const ZeroVectorCreator& other )
        : functions_( other.functions_ ), type_id_( other.type_id_ ),
          impl_( other.impl_ ? other.functions_.clone( other.impl_ ) : nullptr )
    {
    }

    ZeroVectorCreator::ZeroVectorCreator( ZeroVectorCreator&& other ) noexcept : functions_( other.functions_ ),
                                                                                 type_id_( other.type_id_ ),
                                                                                 impl_( other.impl_ )
    {
        other.impl_ = nullptr;
    }

    ZeroVectorCreator::~ZeroVectorCreator()
    {
        reset();
    }

    ZeroVectorCreator& ZeroVectorCreator::operator=( const ZeroVectorCreator& other )
    {
        reset();
        functions_ = other.functions_;
        type_id_ = other.type_id_;
        impl_ = other.impl_ ? other.functions_.clone( other.impl_ ) : nullptr;
        return *this;
    }

    ZeroVectorCreator& ZeroVectorCreator::operator=( ZeroVectorCreator&& other ) noexcept
    {
        reset();
        type_id_ = other.type_id_;
        functions_ = other.functions_;
        impl_ = other.impl_;
        other.impl_ = nullptr;
        return *this;
    }

    ZeroVectorCreator::operator bool() const noexcept
    {
        return impl_ != nullptr;
    }

    Vector ZeroVectorCreator::operator()( const VectorSpace* V ) const
    {
        assert( impl_ );
        return functions_.call_const_VectorSpace_ptr( impl_, V );
    }

    void ZeroVectorCreator::reset() noexcept
    {
        if ( impl_ )
            functions_.del( impl_ );
    }

    Vector zero( const VectorSpace& space )
    {
        return space.creator()( &space );
    }
}
