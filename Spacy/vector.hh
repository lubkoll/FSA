// This file was automatically generated by friendly type erasure.
// Please do not modify.

#pragma once

#include <array>
#include <type_traits>
#include <functional>
#include "Spacy/Util/table_util.hh"
#include <Spacy/Spaces/ScalarSpace/Real.hh>
#include <Spacy/Util/Exceptions/incompatibleSpaceException.hh>
#include <Spacy/Util/Mixins/Get.hh>
#include <Spacy/vectorSpace.hh>
#include "Detail/details_for_vector.hh"

namespace Spacy
{
    /// Type-erased vector.
    class Vector
    {
    public:
        Vector() noexcept;

        template < typename T, typename std::enable_if< VectorDetail::VectorConcept<
                                   Vector, typename std::decay< T >::type >::value >::type* = nullptr >
        Vector( T&& value )
            : functions_(
                  {&type_erasure_table_detail::clone_into_shared_ptr< typename std::decay< T >::type >,
                   &type_erasure_table_detail::clone_into_buffer< typename std::decay< T >::type, Buffer >,
                   &VectorDetail::execution_wrapper< Vector, typename std::decay< T >::type >::call_const_Vector_ref,
                   &VectorDetail::execution_wrapper< Vector, typename std::decay< T >::type >::add_const_Vector_ref,
                   &VectorDetail::execution_wrapper< Vector,
                                                     typename std::decay< T >::type >::subtract_const_Vector_ref,
                   &VectorDetail::execution_wrapper< Vector, typename std::decay< T >::type >::multiply_double,
                   &VectorDetail::execution_wrapper< Vector, typename std::decay< T >::type >::negate,
                   &VectorDetail::execution_wrapper< Vector, typename std::decay< T >::type >::compare_const_Vector_ref,
                   &VectorDetail::execution_wrapper< Vector, typename std::decay< T >::type >::space} ),
              type_id_( typeid( typename std::decay< T >::type ).hash_code() ), impl_( nullptr )
        {
            if ( sizeof( typename std::decay< T >::type ) <= sizeof( Buffer ) )
            {
                new ( &buffer_ ) typename std::decay< T >::type( std::forward< T >( value ) );
                impl_ = std::shared_ptr< typename std::decay< T >::type >(
                    std::shared_ptr< typename std::decay< T >::type >(),
                    static_cast< typename std::decay< T >::type* >( static_cast< void* >( &buffer_ ) ) );
            }
            else
                impl_ = std::make_shared< typename std::decay< T >::type >( std::forward< T >( value ) );
        }

        Vector( const Vector& other );

        Vector( Vector&& other ) noexcept;

        template < typename T, typename std::enable_if< VectorDetail::VectorConcept<
                                   Vector, typename std::decay< T >::type >::value >::type* = nullptr >
        Vector& operator=( T&& value )
        {
            return *this = Vector( std::forward< T >( value ) );
        }

        Vector& operator=( const Vector& other );

        Vector& operator=( Vector&& other ) noexcept;

        /**
         * @brief Checks if the type-erased interface holds an implementation.
         * @return true if an implementation is stored, else false
         */
        explicit operator bool() const noexcept;

        /// Apply as dual space element.
        Real operator()( const Vector& x ) const;

        Vector& operator+=( const Vector& y );

        Vector& operator-=( const Vector& y );

        Vector& operator*=( double a );

        Vector operator-() const;

        bool operator==( const Vector& y ) const;

        /// Access underlying space.
        const VectorSpace& space() const;

        /**
        * @brief Conversion of the stored implementation to @code  T* @endcode.
        * @return pointer to the stored object if conversion was successful, else nullptr
        */
        template < class T >
        T* target() noexcept
        {
            if ( !impl_ )
                return nullptr;
            return type_erasure_table_detail::dynamic_cast_impl< T >( type_id_, write() );
        }

        /**
        * @brief Conversion of the stored implementation to @code const T* @endcode.
        * @return pointer to the stored object if conversion was successful, else nullptr
        */
        template < class T >
        const T* target() const noexcept
        {
            if ( !impl_ )
                return nullptr;
            return type_erasure_table_detail::dynamic_cast_impl< T >( type_id_, read() );
        }

    private:
        using Buffer = std::array< char, 64 >;

        void* read() const noexcept;

        void* write();

        VectorDetail::Functions< Vector, Buffer > functions_;
        std::size_t type_id_;
        std::shared_ptr< void > impl_ = nullptr;
        Buffer buffer_;
    };

    /// Multiplication with arithmetic types (double,float,int,...).
    template < class Arithmetic, class = std::enable_if_t< std::is_arithmetic< Arithmetic >::value > >
    Vector operator*( Arithmetic a, Vector x )
    {
        return x *= a;
    }

    /// Multiplication with arithmetic types (double,float,int,...).
    template < class Arithmetic, class = std::enable_if_t< std::is_arithmetic< Arithmetic >::value > >
    Vector operator*( Vector x, Arithmetic a )
    {
        return x *= a;
    }

    /// Sum of vectors \f$z=x+y\f$.
    Vector operator+( Vector x, const Vector& y );

    /// Subtract vectors \f$z=x-y\f$.
    Vector operator-( Vector x, const Vector& y );

    /// Compute scalar product \f$z=x*y=(x,y)\f$.
    Real operator*( const Vector& x, const Vector& y );

    /// Compute norm, where the norm associated with the underlying function space is used \f$ z = \|x\| \f$.
    Real norm( const Vector& x );

    void checkDualPairing( const Vector& x, const Vector& y );

    template < class T, typename std::enable_if< std::is_arithmetic< T >::value >::type* = nullptr >
    Vector operator*( const Mixin::Get< T >& x, Vector y )
    {
        return y *= get( x );
    }

    template < class T, typename std::enable_if< std::is_arithmetic< T >::value >::type* = nullptr >
    Vector operator*( const Vector& x, const Mixin::Get< T >& y )
    {
        return y * x;
    }

    Vector operator*( const Mixin::Get< Real >& x, Vector y );

    Vector operator*( const Vector& x, const Mixin::Get< Real >& y );
}
