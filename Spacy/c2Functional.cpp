// This file was automatically generated by friendly type erasure.
// Please do not modify.

#include "c2Functional.hh"

namespace Spacy
{
    C2Functional::C2Functional() noexcept : impl_( nullptr )
    {
    }

    C2Functional::C2Functional( const C2Functional& other )
        : functions_( other.functions_ ), type_id_( other.type_id_ ), impl_( other.impl_ )
    {
        if ( !type_erasure_table_detail::is_heap_allocated( other.impl_.get(), other.buffer_ ) )
            other.functions_.clone_into( other.impl_.get(), buffer_, impl_ );
    }

    C2Functional::C2Functional( C2Functional&& other ) noexcept : functions_( other.functions_ ),
                                                                  type_id_( other.type_id_ )
    {
        if ( type_erasure_table_detail::is_heap_allocated( other.impl_.get(), other.buffer_ ) )
            impl_ = std::move( other.impl_ );
        else
            other.functions_.clone_into( other.impl_.get(), buffer_, impl_ );
        other.impl_ = nullptr;
    }

    C2Functional& C2Functional::operator=( const C2Functional& other )
    {
        functions_ = other.functions_;
        type_id_ = other.type_id_;
        impl_ = other.impl_;
        if ( !type_erasure_table_detail::is_heap_allocated( other.impl_.get(), other.buffer_ ) )
            other.functions_.clone_into( other.impl_.get(), buffer_, impl_ );
        return *this;
    }

    C2Functional& C2Functional::operator=( C2Functional&& other ) noexcept
    {
        type_id_ = other.type_id_;
        functions_ = other.functions_;
        if ( type_erasure_table_detail::is_heap_allocated( other.impl_.get(), other.buffer_ ) )
            impl_ = std::move( other.impl_ );
        else
            other.functions_.clone_into( other.impl_.get(), buffer_, impl_ );
        other.impl_ = nullptr;
        return *this;
    }

    C2Functional::operator bool() const noexcept
    {
        return impl_ != nullptr;
    }

    Real C2Functional::operator()( const Vector& x ) const
    {
        assert( impl_ );
        return functions_.call_const_Vector_ref( read(), x );
    }

    Vector C2Functional::d1( const Vector& x ) const
    {
        assert( impl_ );
        return functions_.d1_const_Vector_ref( read(), x );
    }

    Vector C2Functional::d2( const Vector& x, const Vector& dx ) const
    {
        assert( impl_ );
        return functions_.d2_const_Vector_ref_const_Vector_ref( read(), x, dx );
    }

    LinearOperator C2Functional::hessian( const Vector& x ) const
    {
        assert( impl_ );
        return functions_.hessian_const_Vector_ref( read(), x );
    }

    const VectorSpace& C2Functional::domain() const
    {
        assert( impl_ );
        return functions_.domain( read() );
    }

    void* C2Functional::read() const noexcept
    {
        assert( impl_ );
        return impl_.get();
    }

    void* C2Functional::write()
    {
        assert( impl_ );
        if ( !impl_.unique() && type_erasure_table_detail::is_heap_allocated( impl_.get(), buffer_ ) )
            functions_.clone( read(), impl_ );
        return read();
    }

    Vector d1( const C2Functional& f, const Vector& x )
    {
        return f.d1( x );
    }

    LinearOperator d2( const C2Functional& f, const Vector& x )
    {
        return f.hessian( x );
    }
}
