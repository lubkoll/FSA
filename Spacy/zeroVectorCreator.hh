// This file was automatically generated by friendly type erasure.
// Please do not modify.

#pragma once

#include <memory>
#include "Spacy/Util/table_util.hh"
#include <Spacy/vector.hh>
#include <Spacy/vectorSpace.hh>
#include "Detail/details_for_zeroVectorCreator.hh"

namespace Spacy
{
    /// Each VectorSpace needs a zero-vector creator to support generation of vector space elements.
    class ZeroVectorCreator
    {
    public:
        ZeroVectorCreator() noexcept;

        template < typename T, typename std::enable_if< ZeroVectorCreatorDetail::ZeroVectorCreatorConcept<
                                   ZeroVectorCreator, typename std::decay< T >::type >::value >::type* = nullptr >
        ZeroVectorCreator( T&& value )
            : functions_( {&type_erasure_table_detail::delete_impl< typename std::decay< T >::type >,
                           &type_erasure_table_detail::clone_impl< typename std::decay< T >::type >,
                           &ZeroVectorCreatorDetail::execution_wrapper<
                               ZeroVectorCreator, typename std::decay< T >::type >::call_const_VectorSpace_ptr} ),
              type_id_( typeid( typename std::decay< T >::type ).hash_code() ),
              impl_( new typename std::decay< T >::type( std::forward< T >( value ) ) )
        {
        }

        ZeroVectorCreator( const ZeroVectorCreator& other );

        ZeroVectorCreator( ZeroVectorCreator&& other ) noexcept;

        ~ZeroVectorCreator();

        template < typename T, typename std::enable_if< ZeroVectorCreatorDetail::ZeroVectorCreatorConcept<
                                   ZeroVectorCreator, typename std::decay< T >::type >::value >::type* = nullptr >
        ZeroVectorCreator& operator=( T&& value )
        {
            return *this = ZeroVectorCreator( std::forward< T >( value ) );
        }

        ZeroVectorCreator& operator=( const ZeroVectorCreator& other );

        ZeroVectorCreator& operator=( ZeroVectorCreator&& other ) noexcept;

        /**
         * @brief Checks if the type-erased interface holds an implementation.
         * @return true if an implementation is stored, else false
         */
        explicit operator bool() const noexcept;

        /// Creates \f$ 0 \in V \f$
        Vector operator()( const VectorSpace* V ) const;

        /**
        * @brief Conversion of the stored implementation to @code  T* @endcode.
        * @return pointer to the stored object if conversion was successful, else nullptr
        */
        template < class T >
        T* target() noexcept
        {
            if ( !impl_ )
                return nullptr;
            return type_erasure_table_detail::dynamic_cast_impl< T >( type_id_, impl_ );
        }

        /**
        * @brief Conversion of the stored implementation to @code const T* @endcode.
        * @return pointer to the stored object if conversion was successful, else nullptr
        */
        template < class T >
        const T* target() const noexcept
        {
            if ( !impl_ )
                return nullptr;
            return type_erasure_table_detail::dynamic_cast_impl< T >( type_id_, impl_ );
        }

    private:
        void reset() noexcept;

        ZeroVectorCreatorDetail::Functions< ZeroVectorCreator > functions_;
        std::size_t type_id_;
        void* impl_ = nullptr;
    };

    template < class T >
    T& creator( VectorSpace& space )
    {
        return *space.creator().template target< T >();
    }

    template < class T >
    const T& creator( const VectorSpace& space )
    {
        return *space.creator().template target< T >();
    }

    /// Create new vector \f$v=0\f$.
    Vector zero( const VectorSpace& space );
}
