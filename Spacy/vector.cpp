// This file was automatically generated by friendly type erasure.
// Please do not modify.

#include "vector.hh"

namespace Spacy
{
    Vector::Vector() noexcept : impl_( nullptr )
    {
    }

    Vector::Vector( const Vector& other )
        : functions_( other.functions_ ), type_id_( other.type_id_ ), impl_( other.impl_ )
    {
        if ( !type_erasure_table_detail::is_heap_allocated( other.impl_.get(), other.buffer_ ) )
            other.functions_.clone_into( other.impl_.get(), buffer_, impl_ );
    }

    Vector::Vector( Vector&& other ) noexcept : functions_( other.functions_ ), type_id_( other.type_id_ )
    {
        if ( type_erasure_table_detail::is_heap_allocated( other.impl_.get(), other.buffer_ ) )
            impl_ = std::move( other.impl_ );
        else
            other.functions_.clone_into( other.impl_.get(), buffer_, impl_ );
        other.impl_ = nullptr;
    }

    Vector& Vector::operator=( const Vector& other )
    {
        functions_ = other.functions_;
        type_id_ = other.type_id_;
        impl_ = other.impl_;
        if ( !type_erasure_table_detail::is_heap_allocated( other.impl_.get(), other.buffer_ ) )
            other.functions_.clone_into( other.impl_.get(), buffer_, impl_ );
        return *this;
    }

    Vector& Vector::operator=( Vector&& other ) noexcept
    {
        type_id_ = other.type_id_;
        functions_ = other.functions_;
        if ( type_erasure_table_detail::is_heap_allocated( other.impl_.get(), other.buffer_ ) )
            impl_ = std::move( other.impl_ );
        else
            other.functions_.clone_into( other.impl_.get(), buffer_, impl_ );
        other.impl_ = nullptr;
        return *this;
    }

    Vector::operator bool() const noexcept
    {
        return impl_ != nullptr;
    }

    Real Vector::operator()( const Vector& x ) const
    {
        assert( impl_ );
        return functions_.call_const_Vector_ref( *this, read(), x.impl_.get() );
    }

    Vector& Vector::operator+=( const Vector& y )
    {
        assert( impl_ );
        return functions_.add_const_Vector_ref( *this, write(), y.impl_.get() );
    }

    Vector& Vector::operator-=( const Vector& y )
    {
        assert( impl_ );
        return functions_.subtract_const_Vector_ref( *this, write(), y.impl_.get() );
    }

    Vector& Vector::operator*=( double a )
    {
        assert( impl_ );
        return functions_.multiply_double( *this, write(), std::move( a ) );
    }

    Vector Vector::operator-() const
    {
        assert( impl_ );
        return functions_.negate( *this, read() );
    }

    bool Vector::operator==( const Vector& y ) const
    {
        assert( impl_ );
        return functions_.compare_const_Vector_ref( *this, read(), y.impl_.get() );
    }

    const VectorSpace& Vector::space() const
    {
        assert( impl_ );
        return functions_.space( *this, read() );
    }

    void* Vector::read() const noexcept
    {
        assert( impl_ );
        return impl_.get();
    }

    void* Vector::write()
    {
        assert( impl_ );
        if ( !impl_.unique() && type_erasure_table_detail::is_heap_allocated( impl_.get(), buffer_ ) )
            functions_.clone( read(), impl_ );
        return read();
    }

    Vector operator+( Vector x, const Vector& y )
    {
        return x += y;
    }

    Vector operator-( Vector x, const Vector& y )
    {
        return x -= y;
    }

    Real operator*( const Vector& x, const Vector& y )
    {
        return x.space().scalarProduct()( x, y );
    }

    Real norm( const Vector& x )
    {
        return x.space().norm()( x );
    }

    void checkDualPairing( const Vector& x, const Vector& y )
    {
        if ( !y.space().isPrimalWRT( x.space() ) )
            throw IncompatibleSpaceException( x.space().index(), y.space().index() );
    }

    Vector operator*( const Mixin::Get< Real >& x, Vector y )
    {
        return y *= get( get( x ) );
    }

    Vector operator*( const Vector& x, const Mixin::Get< Real >& y )
    {
        return y * x;
    }
}
